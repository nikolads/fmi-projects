\section{Реализация}

\paragraph*{} За реализация на проекта е използван езикът Rust. Използвани са следните външни библиотеки:
\begin{itemize}
\item \verb|clap| - обработка на command line аргументи
\item \verb|crossbeam| - lock-free структури от данни
\item \verb|rand| - генератори на случайни числа
\end{itemize}

Програмата поддържа следните command line аргументи:
\begin{verbatim}
USAGE:
    paralel-dfs [FLAGS] [OPTIONS]

FLAGS:
        --undirected    Generate an undirected graph (defaults to directed)
    -h, --help          Prints help information
    -V, --version       Prints version information

OPTIONS:
    -t, --threads <N>      Number of threads to use
    -n, --vertices <N>     Generate a graph with N vertices
    -m, --edges <N>        Generate a graph with N edges
\end{verbatim}

\subsection*{Thread pool}

\paragraph*{} За разпределяне на работата по множество нишки се използва ръчна имплементация на thread pool. Имплементацията поддържа само най-базовите функции като създаване на n нишки и добавяне на задачи за изпълнение в опашка. За опашката се използва готова имплементация на work-stealing queue от \verb|crossbeam|.

\paragraph*{} Thread pool-а не поддържа връщане на резултат от изпълнението на задачата. За тази цел се използват канали (chanels, multi-producer single-consumer lock-free message queues) от стандартната библиотека на Rust. Те позволяват еднопосочна комуникация между нишки.

\subsection*{Генериране на графа}

\paragraph*{} Каква структура от данни се използва за представяне на графа зависи от това дали е ориентиран или неориентиран. Ако е ориентиран се използва списък на съседство, в противен случай матрица на съседство. С изключение на това имплементацията е почти идентична и следва алгоритъма представен в предишната секция. Освен това и двете представяния имплементират общ интерфейс \verb|Graph|, което означава, че това не се отразява на останалата част от кода.

\paragraph*{} \emph{Забележка:} Не е необходимо да се използва списък на съседство за неориентирания случай, и матрица би работила също толкова добре, но реших че е полезно да има повече варианти за тестване. Обратното обаче не е съвсем вярно, защото за генерирането на ориентиран граф със списъци на наследство най-вероятно ще се наложи значителна синхронизация между нишките.

\subsection*{Обхождане на графа}

\paragraph*{} Дефинираме си дължина на пътя като колко съседа трябва да прескочим в ширина. Използвайки фигура \ref{fig:algorithm} за илюстрация пътят от 3 до 4 има дължина 0, пътят от 3 до 5 има дължина 1, а пътят от 3 до 6 има дължина 2. Пътищата от 0 до 2, 7, 4, 5, 6 имат дължини съответно 0, 1, 1, 2, 3.

\paragraph*{} За всяка дължина си създаваме нова задача и я добавяме в thread pool-а. Понеже не знаем каква ще е максималната дължина която ще достигнем предварително, допълнителни задачи се добавят към thread pool-a по време на изпълнението. Всяка задача обхожда върхове само с определена дължина на пътя. За комуникация между задачите се използват channel-и, като всяка задача си създава собствен канал, запазва си приемащата част за себе си и размножава и разпраща изпращащите части до другите задачи. Всяка задача си има собствен стек (от един елемент) за върховете които обхожда. Когато обходи връх добавя първия му съсед към собствения си стек, а останалите разпраща на други задачи като им изпраща съобщение по channel-а.

\paragraph*{} Вижда се, че задача може да приема съобщения само от задачи с по-малка дължина. Това означава, че задачата може да приключи само ако всички преди нея са приключили. Поради това е важно задачите да бъдат добавени и изпълнение в правилния ред в thread pool-a, иначе ще има deadlock.

\paragraph*{} За да се следи кои върхове са били посетени от кои задачи се използва следната структура.
\begin{verbatim}
struct Visit {
    root_vertex: usize,
    path_len: usize,
    parent_vertex: usize,
}
\end{verbatim}
Масив от такива обекти (по един за всеки връх) е достъпен като споделена памет от всички задачи. Два обекта могат да се сравняват като \verb|a < b| \verb|<=>| \verb|(a.root_vertex, a.path_len, a.parent_vertex)| \verb|<| \verb|(b.root_vertex, b.path_len, b.parent_vertex)| (т.е. лексикографска наредба, \emph{(гррр СЕП)}). Така като някоя задача стигне до посещаван връх проверява дали пътят, по който вмомента обхожда е ``по-кратък'' от предишно намерените.

\subsection*{Оптимизации}

\paragraph*{} Една от основните оптимизации, които се наложи да направя, беше върху структурата \verb|Visit|. В първоначалната си форма споделеният масив имаше тип \verb|Arc<Vec<RwLock<Visit>>>|, където \verb|Arc| e Atomic Reference Counter, \verb|Vec| е Vector, а \verb|RwLock| е Read-Write Lock, тоест синхронизационен обект който позполява едновременно множестово достъпи за четене или един достъп за писане до променливата. Това беше необходимо, защото трябва съдържанието на масива да може да се променя от много нишки едновременно, но означаваше че всеки път когато трябва да се провери кой път е по-кратък се налага да се заключи променливата. А такива заключвания стават постоянно, защото това се намира на hot path-а на програмата.

\paragraph*{} Решението беше да се пренаправи структурата \verb|Visit| до
\begin{verbatim}
struct Visit {
    root_vertex: AtomicUsize,
    path_len: AtomicUsize,
    parent_vertex: AtomicUsize,
    lock: Mutex<()>,
}
\end{verbatim}
Промяната е, че вкарваме синхронизацията вътре във класа, което значи, че масивът може да стане \verb|Arc<Vec<Visit>>|. В този случай можем да правим проверка дали обект е по-малък от tuple \verb|(root, path_len, parent)| (които са нормални nonatomic integer-и) без да заключваме обекта.

\paragraph*{} Това звучи опасно на пръв поглед, защото прочитането на три отделни AtomicUsize променливи не е atomic операция, и можем да видим стари данни, нови данни или мешаница от двете. Но въпреки това знаем, че стойностите, които \verb|Visit| обект приема са монотонно намаляващи, защото такъв обект може да се презапише единствено от стойност по-малка от текущата му. Поради това независимо какви стойности прочетем при load-а, винаги можем да отговорим правилно на въпрос \verb|a < b| с:
\begin{itemize}
\item да, сигурни сме, че \verb|a < b|
\item не знам, може \verb|a < b|, а може и \verb|a >= b|. Заключи променливата и провери отново.
\end{itemize}

\paragraph*{} Дори и да не получаваме категоричен отговор подобна проверка е много полезна, защото ако върне ``да'' значи няма нужда да продължаваме по-нататък с текущия връх. И въпреки, че false positive отговорите увеличават броя пътища които трябва да проверим, премахването на голяма част от lock-овете води до над двойно намаляне във времето за изпълнение.
