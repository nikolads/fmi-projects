\section{Алгоритъм}

\paragraph*{} Решението на задачата може да се раздели на две независими части - генерирането на графа и обхождането му.

\subsection{Генериране на графа}

\paragraph*{} Понеже се иска да генерираме случаен граф, т.е. без някаква определена структура, задачата може да се реши с просто прилагане на принципа паралелизъм по данни. Ако трябва да работим с n нишки, разделяме върховете на графа на n равни части и във всяка част генерираме $ 1 \over n $-та от ребрата. Всяка нишка може да работи в отделна част и не е необходима допълнителна синхронизация между тях.

\subsection{Обхождане на графа}

\paragraph*{} За случая с една нишка се използва стандартния последователен dfs алгоритъм. Това служи за база за сравнение. За многонишковия вариант с K нишки първоначално си създаваме K на брой задачи и ги добавяме в thread pool-а. Всяка задача изпълнява леко модифицирана версия на стандартния dfs алгоритъм, започвайки от първия все-още необходен връх на графа. Всяка задача намира едно дърво на обхождане на свързана компонента от графа. Когато задача приключи се създава нова, докато не бъдат обходени всички върхове от графа.

\paragraph*{} За синхронизация между нишките се използва \verb|used| масив от atomic променливи. Когато задача поиска даден връх се използва \verb|CompareAndSwap| инструкция за да се отбележи, че върха е използван. При успех задачата става собственик на върха и може да го добави към стека си и полученото дърво на обхождането. При неуспех значи, че някоя друга задача я е изпреварила и е получила собственост над върха. Тогава върха се пропуска и се продължава с остатъка от алгоритъма. \verb|CompareAndSwap| инструкцията гарантира, че само една задача може да получи собственост над даден връх.

\paragraph*{} При така показания алгоритъм всяка задача работи само с върхове, които е отбелязала за собствени. Това означава, че  решението ще се различава от това, което бихме получили ако пуснем последователния dfs алгоритъм върху графа. По-точно върхове, които са част от една свързана компонента в графа, могат да бъдат разпределени в няколко различни дървета на обхождане. Това зависи от K - броят нишки върху които разпределяме задачата, както и поредността в която се изпълняват \verb|CompareAndSwap| инструкциите и при по-голям брой нишки се увеличава разпокъсването.

\paragraph*{} Възможно е алгоритъма да се модифицира, така че резултатът да е същия, като от последователен dfs. Това се постига като си дефинираме подреждане на върховете на графа и в \verb|used| масива запазваме кой връх е собственик. Също така се поддържа прехвърляне на собствеността от връх с по-висок номер към връх с по-нисък, като при това съответното поддърво на обхождането в оригиналния собственик става невалидно. Тази инвализация може да стане с линейно обхождане на резултата след приключване на алгоритъма, т.е. не е необходима синхронизация за нея. Така получения алгоритъм ще има идентичен резултат на последователния dfs, но има проблема, че по-голямата част от информацията, която се пресмята, по-късно става невалидна. При това значително се забавя алгоритъма дотолкова, че е по-бавен от еднонишковия вариант. Увеличаването на броя нишки също не помага, защото така рязко се увеличава и количеството информация, която се инвалидира.
